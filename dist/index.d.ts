// Generated by dts-bundle-generator v5.6.0

/// <reference types="cookieclicker" />

declare function alias(oldName: string, aliasName: string): void;
declare function unalias(name: string): void;
declare function resolveAlias(name: string): string;
declare function relinkColumn(link: string, matrix: string[] | string[][], offset?: number, followAlias?: boolean): Promise<void>;
declare function relinkRow(link: string, matrix: string[] | string[][], offset?: number, followAlias?: boolean): Promise<void>;
declare function patchIconsheet(link: string, replacements: [
	[
		number,
		number
	],
	Game.Icon
][], followAlias?: boolean): Promise<void>;
declare function resolveIcon(icon: Game.Icon): Game.Icon;
/**
 * The common type for a value, can be either the value or a function that returns a value with the type.
 */
export declare type CommonValue<T> = T | (() => T);
/**
 * The parameters of an injection, in order: `source`, `target`, `where`
 */
export declare type InjectParams = [
	string | RegExp | null,
	string,
	"before" | "replace" | "after"
];
/**
 * A helper function which replaces(or appends) code in a function, returning the new function, and it's eval free!
 * @param func The source function
 * @param source What to replace, can be null for slicing
 * @param target What to put instead of (or before/after) the source
 * @param where Where to insert or replace your injection
 * @param context The optional context to use
 * @helper
 */
export declare function injectCode<T extends ((...args: any[]) => any) | (new (...args: any[]) => any)>(func: T, source: string | RegExp | null, target: string, where: "before" | "replace" | "after", context?: object): T;
/**
 * A helper function which replaces(or appends) code in a function, returning the new function, and it's eval free!
 * @param func The source function
 * @param injections The injections to apply, the parameters of an injection, in order: `source`, `target`, `where`
 * @param context The optional context to use
 * @helper
 */
export declare function injectCodes<T extends ((...args: any[]) => any) | (new (...args: any[]) => any)>(func: T, injections: InjectParams[], context?: object): T;
export declare type FriendlyHtml = CommonValue<string | HTMLElement>;
export declare function friendlyAppendHtml(value: FriendlyHtml, element: HTMLElement, containerName?: string | null): void;
/**
 * Creates a cookie clicker UI button
 * @param name Text on the button
 * @param description The grey label describing the effects of the button
 * @param onClick Is called on click
 * @param type The color type of the button
 * @param off If it is true, the button is faded out
 * @param additionalClasses Additional classes to add to the button
 */
export declare function ccButton(name: FriendlyHtml, description?: FriendlyHtml | null, onClick?: null | (() => void), type?: "normal" | "warning" | "neato" | null, off?: boolean | null, additionalClasses?: string[]): HTMLDivElement;
/**
 * Creates a section which can be collapsed by a button
 * Note that you need to manually refresh the menu the section is in
 * @param keyname The id name reference to track if the
 * @param title The title of the section, which is never hidden
 * @param body The collapsible part of the section
 * @param onClick Called when the collapse button is clicked
 */
export declare function ccHideableSection(keyname: string, title: FriendlyHtml, body: FriendlyHtml, onClick?: (() => void) | null): HTMLDivElement;
export declare function ccSlider(name: FriendlyHtml, valueFunc: (value: number) => FriendlyHtml, value: number, bounds: [
	number,
	number,
	number?
], onChange?: (newValue: number) => void): HTMLDivElement;
export declare abstract class ToggleBase<C = unknown> {
	keyname: string;
	mod: Mod;
	constructor(keyname: string);
	abstract render(): HTMLElement;
	save?(this: this): C;
	load?(this: this, save: C): void;
}
export declare class Button<C = unknown> extends ToggleBase<C> {
	name: FriendlyHtml;
	description?: FriendlyHtml | undefined;
	onClick?: ((this: Button) => void) | undefined;
	type?: "normal" | "warning" | "neato" | null | undefined;
	additionalClasses: string[];
	off?: boolean;
	constructor(keyname: string, name: FriendlyHtml, description?: FriendlyHtml | undefined, onClick?: ((this: Button) => void) | undefined, type?: "normal" | "warning" | "neato" | null | undefined);
	render(): HTMLDivElement;
}
export declare class MultiStateButton<T extends string[]> extends Button<string> {
	states: T;
	description?: FriendlyHtml | undefined;
	type?: "normal" | "warning" | "neato" | null | undefined;
	state: T[number];
	private stateFunc?;
	constructor(keyname: string, name: FriendlyHtml | ((state: T[number]) => FriendlyHtml), states: T, description?: FriendlyHtml | undefined, onClick?: (this: Button) => void, type?: "normal" | "warning" | "neato" | null | undefined);
	save(): string;
	load(save: string): void;
	render(): HTMLDivElement;
}
export declare class Slider extends ToggleBase<number> {
	name: FriendlyHtml;
	bounds: [
		number,
		number,
		number?
	];
	valueFunc: (value: number) => FriendlyHtml;
	onChange?: ((this: Slider, value: number) => void) | undefined;
	value: number;
	constructor(keyname: string, name: FriendlyHtml, bounds: [
		number,
		number,
		number?
	], valueFunc: (value: number) => FriendlyHtml, defaultValue?: number, onChange?: ((this: Slider, value: number) => void) | undefined);
	save(): number;
	load(save: number): void;
	render(): HTMLDivElement;
}
export declare class ToggleButton extends MultiStateButton<[
	"ON",
	"OFF"
]> {
	description?: CommonValue<string> | undefined;
	type?: "normal" | "warning" | "neato" | null | undefined;
	defaultState?: boolean | undefined;
	constructor(keyname: string, name: FriendlyHtml | ((state: boolean) => FriendlyHtml), description?: CommonValue<string> | undefined, onClick?: (this: ToggleButton) => void, type?: "normal" | "warning" | "neato" | null | undefined, defaultState?: boolean | undefined);
	render(): HTMLDivElement;
}
/**
 * An object which mods can own
 */
export interface OwnershipUnit {
	owner?: Mod;
}
export interface ModMetadata {
	/**
	 * The unique keyname of the mod, can consist of
	 * A-Z a-z 0-9 - _ . ! ~ * ' ( )
	 */
	keyname: string;
	/**
	 * The shown name of the mod, doesn't contain any restrictions
	 */
	name?: string;
	/**
	 * The icon of the mod
	 */
	icon?: Game.Icon;
	/**
	 * The version of the mod, must be in semver
	 */
	version: string;
}
export declare class Mod<C extends object = any> implements ModMetadata {
	modFunction?: ((this: Mod<C>) => void) | undefined;
	/**
	 * The unique keyname of the mod, can consist of
	 * A-Z a-z 0-9 - _ . ! ~ * ' ( )
	 */
	keyname: string;
	/**
	 * The shown name of the mod, doesn't contain any restrictions
	 */
	name?: string;
	/**
	 * The icon of the mod
	 */
	icon?: Game.Icon;
	/**
	 * The version of the mod, must be in semver
	 */
	version: string;
	/**
	 * Custom additional data which mods can read/write to
	 */
	custom: C | null;
	toggles: ToggleBase[];
	ownedUnits: OwnershipUnit[];
	/**
	 * Creates a mod which can have a settings UI and is only launched on Cppkies load
	 * @param metadata The metadata of the mod, it is strongly recommended to set a name
	 * @param modFunction The function which is called when cppkies is loaded
	 */
	constructor(metadata: ModMetadata, modFunction?: ((this: Mod<C>) => void) | undefined);
	render(): HTMLElement;
}
export declare class Achievement extends Game.Achievement implements OwnershipUnit {
	owner?: Mod;
	/**
	 * Creates an achievement
	 * @param name The name of the achievement
	 * @param desc The description of it
	 * @param icon  The icon for it
	 */
	constructor(name: string, desc: string, icon: Game.Icon);
}
export declare class TieredAchievement<Tier extends string | number> extends Achievement implements Game.TieredAchievementClass<Tier> {
	buildingTie: Game.Object;
	pool: "normal";
	tier: Tier;
	/**
	 * Creates an achievement which is won by having an amount of buildings
	 * @param name The name of it
	 * @param quote The optional quote of it
	 * @param tier The upgrade's tier, is the id of the tier, ex. `2`(Berrylium), `7`(Jetmint), etc. (Can be "cursor2" or "cursor50" for special cursor amounts)
	 * @param building The buildings linked to this achievement
	 */
	constructor(name: string, quote: string | null, building: Game.Object | string, tier: Tier | "cursor2" | "cursor50");
}
export declare class BankAchievement extends Achievement implements Game.BankAchievementClass {
	treshold: number;
	/**
	 * Creates an achievement which is automatically unlocked on CBTA amount
	 * @param name Name of the achievement
	 * @param icon The icon of it
	 * @param q The optional quote of it
	 * @param treshold The amount of cookies required, if not set, automatically calculated
	 */
	constructor(name: string, icon: Game.Icon, q?: string | null, treshold?: number);
}
export declare class CpsAchievement extends Achievement implements Game.CpsAchievementClass {
	treshold: number;
	/**
	 * Creates an achievement which is automatically unlocked on CpS amount
	 * @param name Name of the achievement
	 * @param icon The icon of it
	 * @param q The optional quote of it
	 * @param treshold The amount of cookies per second required, if not set, automatically calculated
	 */
	constructor(name: string, icon: Game.Icon, q?: string | null, treshold?: number);
}
export declare class Level10Achievement extends Achievement {
	/**
	 * Creates an achievement which is given for getting level 10 of the building
	 * @param name Name of the achievement
	 * @param building The building to track the level of
	 * @param quote The (optional) quote of it
	 */
	constructor(name: string, building: string | Game.Object, quote?: string | null);
}
export declare class MouseAchievement<Tier extends string | number> extends Achievement {
	pool: "normal";
	tier: Tier;
	/**
	 * Creates an achievement which is unlocked when a specific amount of cookies is made
	 * @param name Name of the achievement
	 * @param quote Quote (flavour text) of it
	 * @param tier The achievement's tier, is the id of the tier, ex. `2`(Berrylium), `7`(Jetmint), `synergy2`(Synergy II), etc.
	 */
	constructor(name: string, tier: Tier, quote: string);
}
export declare class ProductionAchievement extends Achievement {
	/**`
	 * Creates a production achievement (Make \_ from only \_ achievements)
	 * @param name Name of the achievement
	 * @param building The building of the achivement
	 * @param tier The tier of productivity, not the normal tier, fully works with only `1`, `2`, `3`, otherwise icon will be messed up.
	 * @param quote The (optional) quote of it
	 * @param mult The additional multiplier, should be used if the achievement is too easy to obtain
	 */
	constructor(name: string, building: string | Game.Object, tier: number, quote?: string | null, mult?: number | null);
}
export declare class TieredUpgrade<Tier extends string | number = string | number> extends Upgrade implements Game.TieredUpgradeClass<Tier> {
	buildingTie: Game.Object;
	buildingTie1: Game.Object;
	tier: Tier;
	pool: "";
	/**
	 * Creates a tiered upgrade
	 * @param name The name of the tiered upgrade
	 * @param quote The description of the upgrade
	 * @param building The building it boosts
	 * @param tier The upgrade's tier, is the id of the tier, ex. `2`(Berrylium), `7`(Jetmint), `synergy2`(Synergy II), etc.
	 */
	constructor(name: string, quote: string, building: Game.Object | string, tier: Tier);
}
export declare function isFortune(upgrade: TieredUpgrade): upgrade is TieredUpgrade<"fortune">;
/**
 * The class for upgrades
 */
export declare class Upgrade extends Game.Upgrade implements OwnershipUnit {
	owner?: Mod;
	/**
	 * Creates an upgrade
	 * @param name The name of the upgrade
	 * @param desc The description of it
	 * @param price The price of it
	 * @param icon  The icon for it
	 * @param buyFunc The function that gets called when you buy the upgrade
	 */
	constructor(name: string, desc: CommonValue<string>, price: CommonValue<number>, icon: CommonValue<Game.Icon>, buyFunc?: () => void);
}
/**
 * The class for heavenly upgrades
 */
export declare class HeavenlyUpgrade extends Upgrade implements Game.HeavenlyUpgrade {
	posX: number;
	posY: number;
	pool: "prestige";
	/**
	 * Creates a heavenly upgrade
	 * @param name The name for it
	 * @param desc The description of it
	 * @param price The price of in (in Heavenly Chips)
	 * @param icon The icon for it
	 * @param position The position of it on the heavenly map screen
	 * @param parents It's parents, can be mixed ID's with names
	 * @param buyFunc The function which gets called on being bought
	 */
	constructor(name: string, desc: CommonValue<string>, price: CommonValue<number>, icon: CommonValue<Game.Icon>, position: [
		number,
		number
	], parents?: (string | number)[], buyFunc?: () => void);
}
export declare class GrandmaSynergy extends Upgrade implements Game.GrandmaSynergyClass {
	buildingTie: Game.Object;
	pool: "";
	/**
	 * Creates a grandma synergy upgrade
	 * @param name The name for the upgrade(Usually something like "_ Grandmas")
	 * @param quote The flavor text of the upgrade
	 * @param buildingName The building to be tied with
	 * @param grandmaPicture Optional, the picture of the grandma to use in grandma art
	 */
	constructor(name: string, quote: string, building: Game.Object | string, grandmaPicture?: string);
}
export declare class SynergyUpgrade<Tier extends string> extends Upgrade implements Game.SynergyUpgradeClass<Tier> {
	buildingTie1: Game.Object;
	buildingTie2: Game.Object;
	tier: Tier;
	pool: "";
	/**
	 * Creates a synergy upgrade
	 * @param name The name for the upgrade
	 * @param quote The flavor text for it
	 * @param building1 The first building, note that the icon will be inherited from this
	 * @param building2 The second building
	 * @param tier The upgrade's tier, is the id of the tier, ex. `synergy1`(Synergy I), `synergy2`(Synergy II), etc. **Warning: The tier must have a req field**
	 */
	constructor(name: string, quote: string, building1: Game.Object | string, building2: Game.Object | string, tier: Tier);
}
export declare class CursorUpgrade<Tier extends string | number> extends Upgrade implements Game.GenericTieredUpgrade<Tier> {
	pool: "";
	tier: Tier;
	/**
	 * Creates an upgrade which powers up the Thousand Fingers upgrade
	 * @param name Name of the upgrade
	 * @param quote Quote (flavour text) of it
	 * @param tier The upgrade's tier, is the id of the tier, ex. `2`(Berrylium), `7`(Jetmint), `synergy2`(Synergy II), etc.
	 * @param power The multiplier of of thousand fingers, if omitted, 20 by default, which is the multiplier of later cursor upgrades
	 */
	constructor(name: string, quote: string, tier: Tier, power?: number);
}
export declare class KittenUpgrade<Tier extends string | number> extends Upgrade implements Game.KittenUpgrade<Tier> {
	tier: Tier;
	kitten: true;
	pool: "";
	/**
	 * Creates a new kitten upgrade, which boosts CpS based on achievement amount
	 * @param name Name of the upgrade
	 * @param quote The quote (flavour text) of it
	 * @param tier The upgrade's tier, is the id of the tier, ex. `2`(Berrylium), `7`(Jetmint), `synergy2`(Synergy II), etc.
	 * @param power The multiplier of CpS per 25 achievement, if not set, automatically calculated
	 * @param cost The cost of the upgrade, if not set, automatically calculated
	 * @param milkUnlockAmount The milk progess (achievements / 25) required to unlock the upgrade, if not set, automatically calculated
	 */
	constructor(name: string, quote: string, tier: Tier, power?: number | null, cost?: number, milkUnlockAmount?: number | null);
}
export declare class MouseUpgrade<Tier extends string | number> extends Upgrade implements Game.GenericTieredUpgrade<Tier> {
	tier: Tier;
	pool: "";
	/**
	 * Creates an upgrade which powers up the cookies per click
	 * @param name Name of the upgrade
	 * @param quote Quote (flavour text) of it
	 * @param tier The upgrade's tier, is the id of the tier, ex. `2`(Berrylium), `7`(Jetmint), `synergy2`(Synergy II), etc.
	 * @param power The multiplier of CpS per click, `0.01` by default, which is what all other cursor upgrades give
	 */
	constructor(name: string, quote: string, tier: Tier, power?: number);
}
export declare class CookieUpgrade extends Upgrade implements Game.CookieUpgrade {
	power: Upgrade["power"];
	pool: "cookie";
	/**
	 * Create an upgrade which multiplier cookie production
	 * @param name Name of the cookie
	 * @param quote Quote (flavour text) of it
	 * @param price The price of the cookie
	 * @param icon The icon of it
	 * @param power The multiplier of CpS, in %, so `5` means +5% CpS, etc.
	 * @param req Some optional conditions, etc. the season, the upgrade required, or if the upgrade can be unlocked naturally at all to unlock this
	 * (Note: All cookies which aren't locked *require* you to have 1/20 of it's cost to be unlocked)
	 * @param order Position of the cookie in the list, Most cookies have 10020 by default, cookies from boxes and special cookies have different orders.
	 */
	constructor(name: string, quote: string, price: CommonValue<number>, icon: Game.Icon, power: Upgrade["power"], req?: {
		require?: string;
		season?: string;
		locked?: boolean;
	}, order?: number);
}
/**
 * The building class for creating new buildings
 */
export declare class Building extends Game.Object implements OwnershipUnit {
	iconLink: string;
	buildingLink: string;
	owner?: Mod;
	/**
	 * Creates a new building and creates the hooks for it
	 * @param name The name of the building
	 * @param commonName Various additional string for the building, split by |:  The name of the building, then in plural, how the building produced the cookies, the effect from sugar lumps, then in plural
	 * @param desc The description of the building
	 * @param icon The icon for the building (Only the column matters) (See http://cppkies.js.org/#/./CommonProblems?id=relink-column for instructions about the icons)
	 * @param bigIcon The icon that shows up in store (Only the row matters) (See http://cppkies.js.org/#/./CommonProblems?id=big-icons for instructions about the big icons)
	 * @param art The art for the building
	 * @param cpsFunc The function to calculate CPS
	 * @param buyFunction The function which gets called when it's bought
	 * @param foolObject The fool building to display during business day
	 * @param buildingSpecial The building special and building debuff
	 */
	constructor(name: string, commonName: string, desc: string, icon: Game.Icon, bigIcon: Game.Icon, art: Game.Art, cpsFunc: (me: Game.Object) => number, buyFunction: (this: Game.Object) => void, foolObject: Game.FoolBuilding, buildingSpecial: [
		string,
		string
	]);
}
/**
 * The recommended function to pass in building CpsFunc
 * @param me Itself
 */
export declare const DEFAULT_CPS: (me: Building) => number;
/**
 * The reccomended function to pass in building BuyFunc
 */
export declare const DEFAULT_ONBUY: (this: Building) => void;
export declare const miscValues: {
	cookieOrder: number;
	iconLink: string;
	buildingLink: string;
};
export declare class DragonAura implements Game.DragonAura, OwnershipUnit {
	name: string;
	desc: string;
	pic: Game.Icon;
	isCppkies: boolean;
	owner?: Mod;
	/**
	 * Creates a (non-building) dragon aura
	 * @param name Name of the dragon aura (in HTML text)
	 * @param desc Description of it (in HTML text)
	 * @param icon The icon of it
	 */
	constructor(name: string, desc: string, icon: Game.Icon);
	/**
	 * Creates a (building) dragon aura
	 * @param name Name of the dragon aura (in HTML text)
	 * @param desc Description of it (in HTML text)
	 * @param building The building (name or object) to link the aura to
	 */
	constructor(name: string, desc: string, building: string | Game.Object);
}
export declare class DragonLevel implements Game.DragonLevel, OwnershipUnit {
	buy: () => void;
	isCppkies: boolean;
	owner?: Mod;
	/**
	 * The X position of the dragon icon
	 */
	pic: number;
	/**
	 * The Y position of the dragon icon
	 */
	picY: number;
	/**
	 * The link to the dragon icon
	 */
	picLink?: string;
	name: string;
	costStr: () => string;
	cost: () => boolean;
	action: string;
	/**
	 * Creates a new dragon level
	 * @param name Name of the dragon at this level, null for last name
	 * @param desc A string describing the effects of leveling up
	 * @param costDescription A string (or a function) describing the resources required to be able to buy the level
	 * @param canBuy A function which determines if it is possible to buy the level
	 * @param buy A function which spends the required resources
	 * @param icon  Icon of the dragon at this level, null for last icon, note that the icon is 96x96, not 48x48
	 */
	constructor(name: string | null, desc: string, // `this.action`
	costDescription: string | (() => string), // `this.costStr`
	canBuy: () => boolean, // `this.cost`
	buy: () => void, icon?: Game.Icon | null, // `this.pic`, `this.picLink`, and `this.picY`
	order?: number);
}
export declare class DragonAuraLevel extends DragonLevel {
	/**
	 * Creates a level which unlocks an aura
	 * @param auraName Name of the aura
	 * @param auraDesc Short description of the aura, in html text
	 * @param building The building which the aura is tied to
	 */
	constructor(auraName: string, auraDesc: string, building: string | Game.Object);
}
export declare type MilkClass = typeof Game.Milk & Game.ChoiceCosmetics;
export declare class Milk implements MilkClass, OwnershipUnit {
	name: string;
	pic: string;
	special: boolean;
	icon: [
		number,
		number
	];
	iconLink?: string;
	owner?: Mod;
	/**
	 * Creates a new milk type
	 * @param name The name of the milk
	 * @param icon The icon of the mink
	 * @param pic The image to use for the milk itself, must end in .png
	 * @param special If true, the milk is only avaliable via milk selector
	 */
	constructor(name: string, icon: Game.Icon, pic: string, special?: boolean);
}
export declare type EventListenerFunction<T extends Record<string, [
	unknown,
	unknown
]>, N extends keyof T> = (src: T[N][0]) => T[N][1];
export declare type EventList<T extends Record<string, [
	unknown,
	unknown
]>> = {
	[P in keyof T]: EventListenerFunction<T, P>[];
};
declare class ReturnableEventEmitter<T extends Record<string, [
	unknown,
	unknown
]>> {
	_events: EventList<T>;
	forwardTo?: this;
	/**
	 * Registers an event listener which is called each time the event is emitted
	 * @param name Name of the hook
	 * @param func The event listener function
	 */
	on<N extends keyof T>(name: N, func: EventListenerFunction<T, N>): void;
	/**
	 * Registers an event listener which is called for the first time the event is emitted
	 * @param name Name of the hook
	 * @param func The event listener function
	 */
	once<N extends keyof T>(name: N, func: EventListenerFunction<T, N>): void;
	/**
	 * Removes an event listener which was registered before
	 * @param name Name of the hook
	 * @param func The event listener function
	 */
	off<N extends keyof T>(name: N, func: EventListenerFunction<T, N>): void;
	/**
	 * Emits the event, triggering all registered event listeners under the event name and modifying the given value
	 * @param name The name of the event
	 * @param startingValue The starting value for the listeners
	 */
	emit<N extends keyof T>(name: N, ...startingValue: T[N][0] extends void ? [
		undefined?
	] : [
		T[N][0]
	]): T[N][1];
	/**
	 * Emits the event, triggering all registered event listeners under the event name and *not* modifying the given value
	 * @param name The name of the event
	 * @param startingValue The starting value for the listeners
	 */
	constEmit<N extends keyof T>(name: N, ...startingValue: T[N][0] extends void ? [
		undefined?
	] : [
		T[N][0]
	]): void;
	setForwardTarget(target: this): void;
}
export declare const buildingHooks: Record<string, BuildingHooks>;
/**
 * Creates the hooks for a building
 * @param building The building to create hooks for
 */
export declare type BuildingHooks = ReturnableEventEmitter<{
	tooltip: [
		string,
		string
	];
	cps: [
		number,
		number
	];
	buy: [
		void,
		void
	];
	levelUp: [
		void,
		void
	];
}>;
export declare type Hooks = ReturnableEventEmitter<{
	/**
	 * Allows you to add entries to all menus
	 */
	menu: [
		void,
		void
	];
	/**
	 * Allows you to add entries to the options menu
	 */
	optionsMenu: [
		void,
		void
	];
	/**
	 * Allows you to add entries to the stats menu
	 */
	statsMenu: [
		void,
		void
	];
	/**
	 * Allows you to add entries to the info menu
	 */
	infoMenu: [
		void,
		void
	];
	/**
	 * Allows you to execute a function on before saving, useful for cleaning up data which will be invalid if no mod is present
	 */
	preSave: [
		void,
		void
	];
	postSave: [
		void,
		void
	];
	/**
	 * Allows you to execute a function on data reset, useful for custom data resetting
	 * @param hard whether or not this is a hard reset
	 */
	reset: [
		boolean,
		void
	];
	reincarnate: [
		void,
		void
	];
	getIcon: [
		{
			type: string;
			tier: string | number;
			icon: Game.Icon;
		},
		{
			type: string;
			tier: string | number;
			icon: Game.Icon;
		}
	];
	/**
	 * Called after BuildStore, used internally
	 */
	buildStore: [
		void,
		void
	];
	/**
	 * Adds grandma options for the grandma art
	 */
	grandmaPic: [
		string[],
		string[]
	];
	rawCps: [
		number,
		number
	];
	rawCpsMult: [
		number,
		number
	];
	cps: [
		number,
		number
	];
	cpsMult: [
		number,
		number
	];
	/**
	 * The multiplier of cursor finger bonus
	 */
	cursorFingerMult: [
		number,
		number
	];
	/**
	 * Cookies per click
	 */
	cpc: [
		number,
		number
	];
	cpcAdd: [
		number,
		number
	];
	logic: [
		void,
		void
	];
	draw: [
		void,
		void
	];
	check: [
		void,
		void
	];
	ticker: [
		string[],
		string[]
	];
	buildingCps: [
		{
			building: string;
			cps: number;
		},
		{
			building: string;
			cps: number;
		}
	];
	specialPic: [
		{
			tab: string;
			pic: string;
			frame: number;
		},
		{
			tab: string;
			pic: string;
			frame: number;
		}
	];
}>;
export declare const hooks: Hooks;
declare const SAVE_VER: 3;
/**
 * The save type for Cppkies
 */
export interface SaveType {
	saveVer: typeof SAVE_VER;
	mods: Record<string, ModSave>;
	foreign: ModSave;
	dragon: DragonSave;
}
export declare const save: SaveType;
/**
 * The save type for a building
 */
export interface BuildingSave {
	amount: number;
	bought: number;
	free: number;
	totalCookies: number;
	level: number;
	muted: number;
	minigameSave: string;
}
/**
 * The save type for an upgrade
 */
export interface UpgradeSave {
	unlocked: boolean;
	bought: boolean;
}
/**
 * The save type for an achievement
 */
export interface AchievementSave {
	won: boolean;
}
/**
 * The save type for Krumblor
 */
export interface DragonSave {
	level: number | "sync";
	auras: [
		number | "sync",
		number | "sync"
	];
}
/**
 * The save type for a mod
 */
export interface ModSave {
	buildings: Record<string, BuildingSave>;
	upgrades: Record<string, UpgradeSave>;
	achievements: Record<string, AchievementSave>;
	ui: Record<string, unknown>;
	custom: object | null;
}
/**
 * An array of functions to call on Cppkies load
 * Functions pushed here after Cppkies has loaded are executed immediately
 * It is reccomended to use `Cppkies.deffer` instead
 */
export declare const onLoad: Array<() => void>;
/**
 * A promise which is resolved on Cppkies load
 */
export declare const deffer: Promise<void>;
export declare const icons: {
	alias: typeof alias;
	aliases: Record<string, string>;
	extraColumnIcons: Record<string, [
		number,
		number
	]>;
	extraRowIcons: Record<string, [
		number,
		number
	]>;
	patchIconsheet: typeof patchIconsheet;
	relinkColumn: typeof relinkColumn;
	relinkRow: typeof relinkRow;
	resolveAlias: typeof resolveAlias;
	resolveIcon: typeof resolveIcon;
	unalias: typeof unalias;
};

export {};
